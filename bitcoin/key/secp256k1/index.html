<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Rust bindings for Pieter Wuille’s secp256k1 library, which is used for fast and accurate manipulation of ECDSA signatures on the secp256k1 curve. Such signatures are used extensively by the Bitcoin network and its derivatives."><title>bitcoin::key::secp256k1 - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e5308b57e507db71.css" id="mainThemeStyle"><link rel="stylesheet" id="themeStyle" href="../../../static.files/light-d59023bfa12059d2.css"><link rel="stylesheet" disabled href="../../../static.files/dark-1ca41bb1e10af075.css"><link rel="stylesheet" disabled href="../../../static.files/ayu-18b4181a2f3fb862.css"><script src="../../../static.files/storage-3891ce972e3a2bf8.js"></script><script defer src="../../../crates.js"></script><script defer src="../../../static.files/main-98a684e84ae5b08b.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../../../bitcoin/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../../../bitcoin/index.html"><img class="rust-logo" src="../../../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2 class="location"><a href="#">Crate secp256k1</a></h2><div class="sidebar-elems"><ul class="block"><li class="version">Version 1.1.0</li><li><a id="all-types" href="all.html">All Items</a></li></ul><section><ul class="block"><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Crate <a href="../../index.html">bitcoin</a>::<wbr><a href="../index.html">key</a>::<wbr><a class="mod" href="#">secp256k1</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Rust bindings for Pieter Wuille’s secp256k1 library, which is used for
fast and accurate manipulation of ECDSA signatures on the secp256k1
curve. Such signatures are used extensively by the Bitcoin network
and its derivatives.</p>
<p>To minimize dependencies, some functions are feature-gated. To generate
random keys or to re-randomize a context object, compile with the
<code>rand-std</code> feature. If you are willing to use the <code>rand-std</code> feature, we
have enabled an additional defense-in-depth sidechannel protection for
our context objects, which re-blinds certain operations on secret key
data. To de/serialize objects with serde, compile with “serde”.
<strong>Important</strong>: <code>serde</code> encoding is <strong>not</strong> the same as consensus
encoding!</p>
<p>Where possible, the bindings use the Rust type system to ensure that
API usage errors are impossible. For example, the library uses context
objects that contain precomputation tables which are created on object
construction. Since this is a slow operation (10+ milliseconds, vs ~50
microseconds for typical crypto operations, on a 2.70 Ghz i7-6820HQ)
the tables are optional, giving a performance boost for users who only
care about signing, only care about verification, or only care about
parsing. In the upstream library, if you attempt to sign a message using
a context that does not support this, it will trigger an assertion
failure and terminate the program. In <code>rust-secp256k1</code>, this is caught
at compile-time; in fact, it is impossible to compile code that will
trigger any assertion failures in the upstream library.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>secp256k1::rand::rngs::OsRng;
<span class="kw">use </span>secp256k1::{Secp256k1, Message};
<span class="kw">use </span>secp256k1::hashes::sha256;

<span class="kw">let </span>secp = Secp256k1::new();
<span class="kw">let </span>(secret_key, public_key) = secp.generate_keypair(<span class="kw-2">&amp;mut </span>OsRng);
<span class="kw">let </span>message = Message::from_hashed_data::&lt;sha256::Hash&gt;(<span class="string">&quot;Hello World!&quot;</span>.as_bytes());

<span class="kw">let </span>sig = secp.sign_ecdsa(<span class="kw-2">&amp;</span>message, <span class="kw-2">&amp;</span>secret_key);
<span class="macro">assert!</span>(secp.verify_ecdsa(<span class="kw-2">&amp;</span>message, <span class="kw-2">&amp;</span>sig, <span class="kw-2">&amp;</span>public_key).is_ok());</code></pre></div>
<p>If the “global-context” feature is enabled you have access to an alternate API.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>secp256k1::{generate_keypair, Message};
<span class="kw">use </span>secp256k1::hashes::sha256;

<span class="kw">let </span>(secret_key, public_key) = generate_keypair(<span class="kw-2">&amp;mut </span>rand::thread_rng());
<span class="kw">let </span>message = Message::from_hashed_data::&lt;sha256::Hash&gt;(<span class="string">&quot;Hello World!&quot;</span>.as_bytes());

<span class="kw">let </span>sig = secret_key.sign_ecdsa(message);
<span class="macro">assert!</span>(sig.verify(<span class="kw-2">&amp;</span>message, <span class="kw-2">&amp;</span>public_key).is_ok());</code></pre></div>
<p>The above code requires <code>rust-secp256k1</code> to be compiled with the <code>rand-std</code> and <code>bitcoin-hashes-std</code>
feature enabled, to get access to <a href="struct.Secp256k1.html#method.generate_keypair"><code>generate_keypair</code></a>
Alternately, keys and messages can be parsed from slices, like</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>secp256k1::{Secp256k1, Message, SecretKey, PublicKey};

<span class="kw">let </span>secp = Secp256k1::new();
<span class="kw">let </span>secret_key = SecretKey::from_slice(<span class="kw-2">&amp;</span>[<span class="number">0xcd</span>; <span class="number">32</span>]).expect(<span class="string">&quot;32 bytes, within curve order&quot;</span>);
<span class="kw">let </span>public_key = PublicKey::from_secret_key(<span class="kw-2">&amp;</span>secp, <span class="kw-2">&amp;</span>secret_key);
<span class="comment">// This is unsafe unless the supplied byte slice is the output of a cryptographic hash function.
// See the above example for how to use this library together with `bitcoin-hashes-std`.
</span><span class="kw">let </span>message = Message::from_slice(<span class="kw-2">&amp;</span>[<span class="number">0xab</span>; <span class="number">32</span>]).expect(<span class="string">&quot;32 bytes&quot;</span>);

<span class="kw">let </span>sig = secp.sign_ecdsa(<span class="kw-2">&amp;</span>message, <span class="kw-2">&amp;</span>secret_key);
<span class="macro">assert!</span>(secp.verify_ecdsa(<span class="kw-2">&amp;</span>message, <span class="kw-2">&amp;</span>sig, <span class="kw-2">&amp;</span>public_key).is_ok());</code></pre></div>
<p>Users who only want to verify signatures can use a cheaper context, like so:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>secp256k1::{Secp256k1, Message, ecdsa, PublicKey};

<span class="kw">let </span>secp = Secp256k1::verification_only();

<span class="kw">let </span>public_key = PublicKey::from_slice(<span class="kw-2">&amp;</span>[
    <span class="number">0x02</span>,
    <span class="number">0xc6</span>, <span class="number">0x6e</span>, <span class="number">0x7d</span>, <span class="number">0x89</span>, <span class="number">0x66</span>, <span class="number">0xb5</span>, <span class="number">0xc5</span>, <span class="number">0x55</span>,
    <span class="number">0xaf</span>, <span class="number">0x58</span>, <span class="number">0x05</span>, <span class="number">0x98</span>, <span class="number">0x9d</span>, <span class="number">0xa9</span>, <span class="number">0xfb</span>, <span class="number">0xf8</span>,
    <span class="number">0xdb</span>, <span class="number">0x95</span>, <span class="number">0xe1</span>, <span class="number">0x56</span>, <span class="number">0x31</span>, <span class="number">0xce</span>, <span class="number">0x35</span>, <span class="number">0x8c</span>,
    <span class="number">0x3a</span>, <span class="number">0x17</span>, <span class="number">0x10</span>, <span class="number">0xc9</span>, <span class="number">0x62</span>, <span class="number">0x67</span>, <span class="number">0x90</span>, <span class="number">0x63</span>,
]).expect(<span class="string">&quot;public keys must be 33 or 65 bytes, serialized according to SEC 2&quot;</span>);

<span class="kw">let </span>message = Message::from_slice(<span class="kw-2">&amp;</span>[
    <span class="number">0xaa</span>, <span class="number">0xdf</span>, <span class="number">0x7d</span>, <span class="number">0xe7</span>, <span class="number">0x82</span>, <span class="number">0x03</span>, <span class="number">0x4f</span>, <span class="number">0xbe</span>,
    <span class="number">0x3d</span>, <span class="number">0x3d</span>, <span class="number">0xb2</span>, <span class="number">0xcb</span>, <span class="number">0x13</span>, <span class="number">0xc0</span>, <span class="number">0xcd</span>, <span class="number">0x91</span>,
    <span class="number">0xbf</span>, <span class="number">0x41</span>, <span class="number">0xcb</span>, <span class="number">0x08</span>, <span class="number">0xfa</span>, <span class="number">0xc7</span>, <span class="number">0xbd</span>, <span class="number">0x61</span>,
    <span class="number">0xd5</span>, <span class="number">0x44</span>, <span class="number">0x53</span>, <span class="number">0xcf</span>, <span class="number">0x6e</span>, <span class="number">0x82</span>, <span class="number">0xb4</span>, <span class="number">0x50</span>,
]).expect(<span class="string">&quot;messages must be 32 bytes and are expected to be hashes&quot;</span>);

<span class="kw">let </span>sig = ecdsa::Signature::from_compact(<span class="kw-2">&amp;</span>[
    <span class="number">0xdc</span>, <span class="number">0x4d</span>, <span class="number">0xc2</span>, <span class="number">0x64</span>, <span class="number">0xa9</span>, <span class="number">0xfe</span>, <span class="number">0xf1</span>, <span class="number">0x7a</span>,
    <span class="number">0x3f</span>, <span class="number">0x25</span>, <span class="number">0x34</span>, <span class="number">0x49</span>, <span class="number">0xcf</span>, <span class="number">0x8c</span>, <span class="number">0x39</span>, <span class="number">0x7a</span>,
    <span class="number">0xb6</span>, <span class="number">0xf1</span>, <span class="number">0x6f</span>, <span class="number">0xb3</span>, <span class="number">0xd6</span>, <span class="number">0x3d</span>, <span class="number">0x86</span>, <span class="number">0x94</span>,
    <span class="number">0x0b</span>, <span class="number">0x55</span>, <span class="number">0x86</span>, <span class="number">0x82</span>, <span class="number">0x3d</span>, <span class="number">0xfd</span>, <span class="number">0x02</span>, <span class="number">0xae</span>,
    <span class="number">0x3b</span>, <span class="number">0x46</span>, <span class="number">0x1b</span>, <span class="number">0xb4</span>, <span class="number">0x33</span>, <span class="number">0x6b</span>, <span class="number">0x5e</span>, <span class="number">0xcb</span>,
    <span class="number">0xae</span>, <span class="number">0xfd</span>, <span class="number">0x66</span>, <span class="number">0x27</span>, <span class="number">0xaa</span>, <span class="number">0x92</span>, <span class="number">0x2e</span>, <span class="number">0xfc</span>,
    <span class="number">0x04</span>, <span class="number">0x8f</span>, <span class="number">0xec</span>, <span class="number">0x0c</span>, <span class="number">0x88</span>, <span class="number">0x1c</span>, <span class="number">0x10</span>, <span class="number">0xc4</span>,
    <span class="number">0xc9</span>, <span class="number">0x42</span>, <span class="number">0x8f</span>, <span class="number">0xca</span>, <span class="number">0x69</span>, <span class="number">0xc1</span>, <span class="number">0x32</span>, <span class="number">0xa2</span>,
]).expect(<span class="string">&quot;compact signatures are 64 bytes; DER signatures are 68-72 bytes&quot;</span>);

<span class="macro">assert!</span>(secp.verify_ecdsa(<span class="kw-2">&amp;</span>message, <span class="kw-2">&amp;</span>sig, <span class="kw-2">&amp;</span>public_key).is_ok());</code></pre></div>
<p>Observe that the same code using, say <a href="struct.Secp256k1.html#method.signing_only"><code>signing_only</code></a>
to generate a context would simply not compile.</p>
<h3 id="crate-featuresoptional-dependencies"><a href="#crate-featuresoptional-dependencies">Crate features/optional dependencies</a></h3>
<p>This crate provides the following opt-in Cargo features:</p>
<ul>
<li><code>std</code> - use standard Rust library, enabled by default.</li>
<li><code>alloc</code> - use the <code>alloc</code> standard Rust library to provide heap allocations.</li>
<li><code>rand</code> - use <code>rand</code> library to provide random generator (e.g. to generate keys).</li>
<li><code>rand-std</code> - use <code>rand</code> library with its <code>std</code> feature enabled. (Implies <code>rand</code>.)</li>
<li><code>bitcoin-hashes</code> - use the <code>bitcoin_hashes</code> library.</li>
<li><code>bitcoin-hashes-std</code> - use the <code>bitcoin_hashes</code> library with its <code>std</code> feature enabled (implies <code>bitcoin-hashes</code>).</li>
<li><code>recovery</code> - enable functions that can compute the public key from signature.</li>
<li><code>lowmemory</code> - optimize the library for low-memory environments.</li>
<li><code>global-context</code> - enable use of global secp256k1 context (implies <code>std</code>).</li>
<li><code>serde</code> - implements serialization and deserialization for types in this crate using <code>serde</code>.
<strong>Important</strong>: <code>serde</code> encoding is <strong>not</strong> the same as consensus encoding!</li>
</ul>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="constants/index.html" title="mod bitcoin::key::secp256k1::constants">constants</a></div><div class="desc docblock-short">Constants related to the API and the underlying curve.</div></li><li><div class="item-name"><a class="mod" href="ecdh/index.html" title="mod bitcoin::key::secp256k1::ecdh">ecdh</a></div><div class="desc docblock-short">Support for shared secret computations.</div></li><li><div class="item-name"><a class="mod" href="ecdsa/index.html" title="mod bitcoin::key::secp256k1::ecdsa">ecdsa</a></div><div class="desc docblock-short">Structs and functionality related to the ECDSA signature algorithm.</div></li><li><div class="item-name"><a class="mod" href="ffi/index.html" title="mod bitcoin::key::secp256k1::ffi">ffi</a></div><div class="desc docblock-short">secp256k1-sys FFI bindings</div></li><li><div class="item-name"><a class="mod" href="hashes/index.html" title="mod bitcoin::key::secp256k1::hashes">hashes</a></div><div class="desc docblock-short">Rust hashes library.</div></li><li><div class="item-name"><a class="mod" href="rand/index.html" title="mod bitcoin::key::secp256k1::rand">rand</a></div><div class="desc docblock-short">Utilities for random number generation</div></li><li><div class="item-name"><a class="mod" href="scalar/index.html" title="mod bitcoin::key::secp256k1::scalar">scalar</a></div><div class="desc docblock-short">Provides <a href="struct.Scalar.html" title="struct bitcoin::key::secp256k1::Scalar"><code>Scalar</code></a> and related types.</div></li><li><div class="item-name"><a class="mod" href="schnorr/index.html" title="mod bitcoin::key::secp256k1::schnorr">schnorr</a></div><div class="desc docblock-short">Support for schnorr signatures.</div></li></ul><h2 id="macros" class="small-section-header"><a href="#macros">Macros</a></h2><ul class="item-table"><li><div class="item-name"><a class="macro" href="macro.impl_array_newtype.html" title="macro bitcoin::key::secp256k1::impl_array_newtype">impl_array_newtype</a></div><div class="desc docblock-short">Implement methods and traits for types that contain an inner array.</div></li></ul><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.AllPreallocated.html" title="struct bitcoin::key::secp256k1::AllPreallocated">AllPreallocated</a></div><div class="desc docblock-short">Represents the set of all capabilities (preallocated memory).</div></li><li><div class="item-name"><a class="struct" href="struct.InvalidParityValue.html" title="struct bitcoin::key::secp256k1::InvalidParityValue">InvalidParityValue</a></div><div class="desc docblock-short">Error returned when conversion from an integer to <code>Parity</code> fails.</div></li><li><div class="item-name"><a class="struct" href="struct.KeyPair.html" title="struct bitcoin::key::secp256k1::KeyPair">KeyPair</a></div><div class="desc docblock-short">Opaque data structure that holds a keypair consisting of a secret and a public key.</div></li><li><div class="item-name"><a class="struct" href="struct.Message.html" title="struct bitcoin::key::secp256k1::Message">Message</a></div><div class="desc docblock-short">A (hashed) message input to an ECDSA signature.</div></li><li><div class="item-name"><a class="struct" href="struct.PublicKey.html" title="struct bitcoin::key::secp256k1::PublicKey">PublicKey</a></div><div class="desc docblock-short">A Secp256k1 public key, used for verification of signatures.</div></li><li><div class="item-name"><a class="struct" href="struct.Scalar.html" title="struct bitcoin::key::secp256k1::Scalar">Scalar</a></div><div class="desc docblock-short">Positive 256-bit integer guaranteed to be less than the secp256k1 curve order.</div></li><li><div class="item-name"><a class="struct" href="struct.Secp256k1.html" title="struct bitcoin::key::secp256k1::Secp256k1">Secp256k1</a></div><div class="desc docblock-short">The secp256k1 engine, used to execute all signature operations.</div></li><li><div class="item-name"><a class="struct" href="struct.SecretKey.html" title="struct bitcoin::key::secp256k1::SecretKey">SecretKey</a></div><div class="desc docblock-short">Secret 256-bit key used as <code>x</code> in an ECDSA signature.</div></li><li><div class="item-name"><a class="struct" href="struct.SignOnlyPreallocated.html" title="struct bitcoin::key::secp256k1::SignOnlyPreallocated">SignOnlyPreallocated</a></div><div class="desc docblock-short">Represents the set of capabilities needed for signing (preallocated memory).</div></li><li><div class="item-name"><a class="struct" href="struct.VerifyOnlyPreallocated.html" title="struct bitcoin::key::secp256k1::VerifyOnlyPreallocated">VerifyOnlyPreallocated</a></div><div class="desc docblock-short">Represents the set of capabilities needed for verification (preallocated memory).</div></li><li><div class="item-name"><a class="struct" href="struct.XOnlyPublicKey.html" title="struct bitcoin::key::secp256k1::XOnlyPublicKey">XOnlyPublicKey</a></div><div class="desc docblock-short">An x-only public key, used for verification of schnorr signatures and serialized according to BIP-340.</div></li></ul><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.All.html" title="enum bitcoin::key::secp256k1::All">All</a></div><div class="desc docblock-short">Represents the set of all capabilities.</div></li><li><div class="item-name"><a class="enum" href="enum.Error.html" title="enum bitcoin::key::secp256k1::Error">Error</a></div><div class="desc docblock-short">The main error type for this library.</div></li><li><div class="item-name"><a class="enum" href="enum.Parity.html" title="enum bitcoin::key::secp256k1::Parity">Parity</a></div><div class="desc docblock-short">Represents the parity passed between FFI function calls.</div></li><li><div class="item-name"><a class="enum" href="enum.SignOnly.html" title="enum bitcoin::key::secp256k1::SignOnly">SignOnly</a></div><div class="desc docblock-short">Represents the set of capabilities needed for signing.</div></li><li><div class="item-name"><a class="enum" href="enum.VerifyOnly.html" title="enum bitcoin::key::secp256k1::VerifyOnly">VerifyOnly</a></div><div class="desc docblock-short">Represents the set of capabilities needed for verification.</div></li></ul><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Context.html" title="trait bitcoin::key::secp256k1::Context">Context</a></div><div class="desc docblock-short">A trait for all kinds of contexts that lets you define the exact flags and a function to
deallocate memory. It isn’t possible to implement this for types outside this crate.</div></li><li><div class="item-name"><a class="trait" href="trait.PreallocatedContext.html" title="trait bitcoin::key::secp256k1::PreallocatedContext">PreallocatedContext</a></div><div class="desc docblock-short">Trait marking that a particular context object internally points to
memory that must outlive <code>'a</code></div></li><li><div class="item-name"><a class="trait" href="trait.Signing.html" title="trait bitcoin::key::secp256k1::Signing">Signing</a></div><div class="desc docblock-short">Marker trait for indicating that an instance of <a href="../struct.Secp256k1.html" title="struct bitcoin::key::Secp256k1"><code>Secp256k1</code></a> can be used for signing.</div></li><li><div class="item-name"><a class="trait" href="trait.ThirtyTwoByteHash.html" title="trait bitcoin::key::secp256k1::ThirtyTwoByteHash">ThirtyTwoByteHash</a></div><div class="desc docblock-short">Trait describing something that promises to be a 32-byte random number; in particular,
it has negligible probability of being zero or overflowing the group order. Such objects
may be converted to <code>Message</code>s without any error paths.</div></li><li><div class="item-name"><a class="trait" href="trait.Verification.html" title="trait bitcoin::key::secp256k1::Verification">Verification</a></div><div class="desc docblock-short">Marker trait for indicating that an instance of <a href="../struct.Secp256k1.html" title="struct bitcoin::key::Secp256k1"><code>Secp256k1</code></a> can be used for verification.</div></li></ul></section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="bitcoin" data-themes="" data-resource-suffix="" data-rustdoc-version="1.69.0-nightly (31f858d9a 2023-02-28)" data-search-js="search-d5a6cd8418084717.js" data-settings-js="settings-f0c5c39777a9a2f6.js" data-settings-css="settings-0bcba95ff279c1db.css" ></div></body></html>